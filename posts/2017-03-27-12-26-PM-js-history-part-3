---
preview: ![](https://habrastorage.org/files/1d4/b17/670/1d4b176701b74c81b3f4c58dfc6f1488.jpg)
Третья и заключительная часть перевода статьи из блога сервиса Auth0 A Brief History of JavaScript. Ключевые моменты: транспайлеры и ECMAScript 2015, немного о новом процессе подготовки обновлений, чего ждать в будущем и как на него повлияют Asm.js и WebAssembly. Перевод подготовлен отделом фронтенд-разработки компании Лайв Тайпинг.
title: Краткая история JavaScript. Часть 3
tags: JavaScript, Блог компании Лайв Тайпинг
author: Acid-base
date: 2017-03-27 15:26:00
---
ECMAScript 6 (2015) и 7 (2016): универсальный язык программирования

План ECMAScript Harmony стал основой для последующих улучшений JavaScript. Многие идеи из ECMAScript 4 канули в лету ради всеобщего блага, однако некоторые были пересмотрены. ECMAScript 6, позже переименованный в ECMAScript 2015, должен был принести большие перемены. Почти все обновления, так или иначе влиявшие на синтаксис, были отложены именно для этой версии. К 2015 году комитет, наконец, смог побороть все внутренние разногласия, и ECMAScript 6 увидел свет. Большинство производителей браузеров уже работали над поддержкой этой версии, однако до сих пор не все браузеры имеют полную совместимость с ECMAScript 2015. 

Выход ECMAScript 2015 стал причиной резкого роста популярности транспайлеров, таких, как Babel или Traceur. Благодаря тому, что производители этих транспайлеров следили за работой технического комитета, у многих людей появилась возможность испытать преимущества ECMAScript 2015 задолго до его выхода.

Некоторые из основных возможностей ECMAScript 4 были реализованы в этой версии с несколько иным подходом. Например, классы в ECMAScript 2015 — это нечто большее, чем просто синтаксический сахар поверх прототипов. Подобный подход облегчает разработку и внедрение новых возможностей.

Мы (редакция блога Auth0 — прим. пер.) делали подробный обзор новых возможностей ECMAScript 2015 в нашей статье «Краткое изложение возможностей JavaScript». Вы также можете ознакомиться с таблицей совместимости ECMAScript, чтобы получить представление о том, как проходит процесс реализации.

Краткий список новых возможностей включает в себя:

Let (лексическая) и const (неизменяемая) привязки
Стрелочные функции (короткие анонимные функции) и лексическое this
Классы (синтаксический сахар поверх прототипов)
Улучшения объектных литералов (вычисляемые ключи, укороченные определения методов и т.д.)
Шаблонные строки
Промисы
Генераторы, итерируемые объекты, итераторы и for..of
Параметры функций по умолчанию и оператор rest
Spread-синтакис
Деструктуризация
Модульный синтаксис
Новые коллекции (Set, Map, WeakSet, WeakMap)
Прокси и Reflect
Тип данных Symbols
Типизированные массивы
Наследование классов
Оптимизация хвостовой рекурсии
Упрощённая поддержка Unicode
Двоичные и восьмеричные литералы

Все эти возможности открыли JavaScript для ещё большего количества программистов и внесли существенный вклад в большое программирование.

Некоторых может удивить, как могло такое количество новых возможностей проскочить мимо процесса стандартизации, во время которого был загублен ECMAScript 4. Хотелось бы отметить, что большинство наиболее агрессивных инноваций ECMAScript 4, таких, как пространства имён или опциональное типирование, были забыты и к ним больше не возвращались, в то время, как другие были переосмыслены с учётом возникших возражений. Работа над ECMAScript 2015 была очень тяжёлой и заняла почти шесть лет (и даже больше, учитывая время, необходимое на реализацию). Но сам факт того, что технический комитет ECMAScript смог справиться с таким трудным заданием, стал добрым знамением.

В 2016 году увидело свет небольшое обновление ECMAScript. Эта версия стала результатом нового процесса подготовки, принятого в TC-39. Все новые предложения должны пройти через четыре стадии. Предложение, достигшее четвёртой стадии, имеет все шансы быть включенным в следующую версию ECMAScript (однако комитет имеет право отложить его для более поздней версии). Таким образом, каждое предложение разрабатывается индивидуально (разумеется, с учётом его взаимодействия с другими предложениями), не тормозя разработку ECMAScript. 

Если предложение готово к включению в стандарт, и достаточное количество других предложений достигло четвёртой стадии, в свет выходит новая версия ECMAScript.

Версия, выпущенная в 2016 году, была очень маленькой. Она включала в себя:

Оператор возведения в степень (**)
Array.prototype.includes
Несколько незначительных поправок (генераторы не могут быть использованы с new и т.д.)

И всё же несколько интересных предложений уже достигли четвёртой стадии в 2016 году. Что же готовит для нас ECMAScript?

Будущее близкое и не очень: ECMAScript 2017 и следующие версии

Самым важным предложением, достигшим четвёртой стадии, является async/await. это расширение синтаксиса для JavaScript, которое делает работу с промисами более приятной. Для примера рассмотрим код ECMAScript 2015:

function apiDoSomethingMoreComplex(withThis) {
    const urlA = '...';
    const urlB = '...';

    httpLib.request(urlA, withThis).then(result => {
        const parsed = parseResult(result);
        return new Promise((resolve, reject) => {
            database.update(updateStatement, parsed).then(() => {
                resolve(parsed);
            }, error => {
                reject(error);
            });
        });
    }).then(result => {
        return httpLib.request(urlB, result);
    }).then(result => {
        return worker.processData(result);
    }).then(result => {
        logger.info(`apiDoSomethingMoreComplex success (${result})`);
    }, error => {
        logger.error(error);
    });
}

И сравним его с кодом, в котором используется async/await:

async function apiDoSomethingMoreComplex(withThis) {
    const urlA = '...';
    const urlB = '...';

    try { 
        let result = await httpLib.request(urlA, withThis);
        const parsed = parseResult(result);
        await database.update(updateStatement, parsed);
        result = await httpLib.request(urlB, parsed);
        result = await worker.processData(result);
        logger.info(`apiDoSomethingMoreComplex success (${result})`);
    } catch(e) {
        logger.error(e);
    }
}

Другие предложения, достигшие четвёртой стадии, совсем небольшие:

Object.values и Object.entries
Выравнивание строк
Object.getOwnPropertyDescriptors
Разделители-запятые в параметрах функций

Все эти предложения предназначены для релиза 2017 года, однако комитет имеет право отложить их до следующего релиза. Но даже одно лишь дополнение в лице async/await будет потрясающим.

Будущее на этом не заканчивается. Давайте посмотрим на некоторые другие предложения, чтобы получить представление о том, что ждёт нас впереди. Вот несколько самых интересных:

SIMD API
Асинхронные итераторы (async/await + итерация)
Стрелочные генераторы
Операции с 64-битными целыми числами
Области (изоляции состояний)
Общая память и Atomics

JavaScript всё больше становится похож на язык общего назначения. Но есть ещё одна большая деталь в будущем JavaScript, которая внесёт свои коррективы.

WebAssembly

Если вы не слышали о WebAssembly, вам стоит прочитать про него. Огромное количество библиотек и фреймворков, появившихся после выхода ECMAScript 5, а также общее развитие языка, сделали JavaScript интересной целью для других языков. Для больших кодовых структур функциональная совместимость является ключевой потребностью. Возьмите, к примеру, игры. Самым распространённым языком, на котором пишутся игры, является C++, благодаря чему их можно портировать на большое количество архитектур. Тем не менее портирование для браузера Windows или консольной игры считалось невыполнимой задачей. Однако это стало возможным благодаря стремительному развитию и небывалой эффективности сегодняшних виртуальных машин JavaScript. Именно для выполнения подобных задач на свет появились инструменты вроде Emscripten.

Быстро сориентировавшись в ситуации, Mozilla начала работу над тем, чтобы сделать JavaScript подходящей целью для компиляторов. Так на свет появился Asm.js — подмножество JavaScript, идеально подходящее в качестве подобной цели. Виртуальные машины JavaScript могут быть оптимизированы для распознавания этого подмножества и производства кода, намного лучшего, чем тот, который генерируют текущие виртуальные машины. Благодаря JavaScript браузеры медленно становятся новой целью для компиляторов.

И всё же существуют огромные ограничения, которые не в состоянии преодолеть даже Asm.js. В JavaScript необходимо внести такие изменения, которые расходятся с его текущим предназначением. Нужно что-то совершенно иное для того, чтобы сделать веб достойной целью для других языков программирования. И именно для этого предназначен WebAssembly — низкоуровневый язык программирования для веба. Любая программа может быть скомпилирована в WebAssembly при помощи подходящего компилятора и затем запущена в подходящей виртуальной машине (виртуальные машины JavaScript могут предоставить необходимый уровень семантики). Первые версии WebAssembly имеют стопроцентную совместимость со спецификацией Web.js. WebAssembly обещает не только более быстрое время загрузки (байт-код обрабатывается быстрее, чем текст), но и возможность оптимизации, недоступной в Asm.js. Представьте себе интернет с идеальной функциональной совместимостью между JavaScript и вашим языком программирования.

На первый взгляд это может помешать росту JavaScript, но на самом деле всё совершенно иначе. Благодаря тому, что другие языки и фреймворки получат функциональную совместимость с JavaScript, он сможет продолжать свое развитие в качестве языка общего назначения. И WebAssembly является необходимым инструментом для этого.

В настоящий момент dev-версии Chrome, Firefox и Microsoft Edge имеют начальную поддержку WebAssembly и способны проигрывать демо-приложения.

Использование JavaScript в Auth0

Мы в Auth0 очень плотно используем JavaScript, который является основным языком программирования везде, от Lock library до бэкендов. Его асинхронная натура и предельная простота для новых разработчиков являются ключевыми факторами нашего успеха. Мы с интересом наблюдаем за развитием языка и за его влиянием на всю экосистему.
Пройдите бесплатную регистрацию на Auth0 и ознакомьтесь с экосистемой, полностью написанной на JavaScript. Не беспокойтесь, у нас есть клиентские библиотеки для всех популярных фреймворков и платформ.

Заключение

История JavaScript длинна и полна неожиданных поворотов. Изначально предложенный в качестве «Scheme для веба», он позаимствовал свой синтаксис у Java. Его первый прототип был разработан за несколько недель. Подстраиваясь под требования рынка, он сменил три названия менее чем за два года, после чего был стандартизирован и получил название, болee подходящее для кожного заболевания. После трёх успешных релизов язык варился в адских котлах почти восемь лет. Затем, благодаря успеху одной-единственной технологии (AJAX), сообщество смогло побороть противоречия и возобновить разработку. Версия 4 была заброшена, а небольшое обновление, известное, как версия 3.1, было переименовано в версию 5. Версия 6 провела в разработке много лет (опять), но на этот раз комитет успешно закончил работу, сменив цифру в названии на 2015. Это было очень большое обновление, и его реализация заняла много времени. В результате JavaScript получил второе дыхание. Сообщество оживилось как никогда до этого. Благодаря Node.js, V8 и другим проектам JavaScript поднялся на высоты, о которых разработчики первой версии даже не задумывались, а благодаря Asm.js и WebAssembly он взлетит ещё выше. Активные предложения, пребывающие в разных стадиях, делают будущее JavaScript чистым и безоблачным. Пройдя долгий путь, полный неожиданных поворотов и препятствий, JavaScript остаётся одним из самых успешных языков в истории программирования. И это — лучшее доказательство его надежности. Всегда ставьте на JavaScript.